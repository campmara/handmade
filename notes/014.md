# Day 014: Platform-independent Game Memory

Memory is a limited resource. Every time you do a memory allocation it could fail! Most of the time we won't run out of memory, but it's important to limit the amount of times we allocate memory (memory arenas incoming?).

We are going to grab a flat partition (a chunk) of memory at the beginning, pre-deecide how much space each sub-system is going to be allowed to use, and then the sub-systems will be written such that they must run in that space.

`local_persist` is a global variable scoped to a function!

## The 'Usual' Method

The usual method people take to allocate game state memory is more or less what I would assume I'd need to do as of right now:

```c++
struct GameState
{
    int value0;
    int value1;
    int value2;
};

internal GameState *GameStartup()
{
    GameState *game_state = new GameState();
    if (game_state)
    {
        game_state->value0 = 0;
        game_state->value1 = 0;
        game_state->value2 = 256;
        // etc...
    }
    return game_state;
}

internal void GameShutdown(GameState *game_state)
{
    delete game_state;
}
```

There are problems with that method, though:
* This essentially will litter your code with news and deletes.
* It makes memory management very opaque.
* Each allocation is a trip to and from the platform layer.

## What we will do instead:

We will instead allocate all of the memory for the game in one VirtualAlloc call at startup, and then partition that out to subsystems. This means that once the game starts up and we get that memory, we know that the game *will not fail*.

We will subdivide the memory into a few different partitions:
* scratch space 
  * not about storing the game and could go away at any time
* permanent space 
  * needs to persist between frames for the whole game